"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.computeBitcoinAddressFromPublicKey = computeBitcoinAddressFromPublicKey;
exports.computeEthereumAddressFromPublicKey = computeEthereumAddressFromPublicKey;

var bitcoin = _interopRequireWildcard(require("bitcoinjs-lib"));

var _elliptic = require("elliptic");

var _jsSha = require("js-sha3");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function computeBitcoinAddressFromPublicKey(publicKey, chain) {
  return bitcoin.payments.p2pkh({
    pubkey: publicKey,
    network: bitcoin.networks[chain.code]
  }).address;
}

function computeEthereumAddressFromPublicKey(publicKey, chain) {
  const publicKeyString = publicKey.toString('hex'); // eslint-disable-next-line new-cap

  const ellipticCurve = new _elliptic.ec('secp256k1'); // Decode public key

  const key = ellipticCurve.keyFromPublic(publicKeyString, 'hex'); // Convert to uncompressed format

  const publicKeyUncompressed = key.getPublic().encode('hex').slice(2); // Now apply keccak

  const address = (0, _jsSha.keccak256)(Buffer.from(publicKeyUncompressed, 'hex')).slice(64 - 40);
  return `0x${address.toString()}`;
}