"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUnmappedFields = getUnmappedFields;
exports.default = computeLocalHash;

require("core-js/modules/es.array.sort.js");

require("core-js/modules/es.promise.js");

var _certificateVersions = require("../constants/certificateVersions");

var _config = _interopRequireDefault(require("../constants/config"));

var _jsonld = _interopRequireDefault(require("jsonld"));

var _verifierError = _interopRequireDefault(require("../models/verifierError"));

var _verificationSubSteps = require("../constants/verificationSubSteps");

var _sha = _interopRequireDefault(require("sha256"));

var _constants = require("../constants");

var _data = require("../helpers/data");

var _useCases = require("../domain/i18n/useCases");

function getUnmappedFields(normalized) {
  const normalizedArray = normalized.split('\n');
  const myRegexp = /<http:\/\/fallback\.org\/(.*)>/;
  const matches = normalizedArray.map(normalizedString => myRegexp.exec(normalizedString)).filter(match => match != null);

  if (matches.length > 0) {
    const unmappedFields = matches.map(match => match[1]).sort(); // only return name of unmapped key

    return Array.from(new Set(unmappedFields)); // dedup
  }

  return null;
}

async function computeLocalHash(document, version) {
  let expandContext = document['@context'];
  const theDocument = document;

  if (!(0, _certificateVersions.isV1)(version) && _config.default.CheckForUnmappedFields) {
    if (expandContext.find(x => x === Object(x) && '@vocab' in x)) {
      expandContext = null;
    } else {
      expandContext.push({
        '@vocab': 'http://fallback.org/'
      });
    }
  }

  const customLoader = function (url) {
    if (url in _constants.preloadedContexts) {
      return {
        contextUrl: null,
        document: _constants.preloadedContexts[url],
        documentUrl: url
      };
    }

    return _jsonld.default.documentLoader(url);
  };

  const normalizeArgs = {
    algorithm: 'URDNA2015',
    format: 'application/nquads',
    documentLoader: customLoader
  };

  if (expandContext) {
    normalizeArgs.expandContext = expandContext;
  }

  let normalizedDocument;

  try {
    normalizedDocument = await _jsonld.default.normalize(theDocument, normalizeArgs);
  } catch (e) {
    console.error(e);
    throw new _verifierError.default(_verificationSubSteps.SUB_STEPS.computeLocalHash, (0, _useCases.getText)('errors', 'failedJsonLdNormalization'));
  }

  const unmappedFields = getUnmappedFields(normalizedDocument);

  if (unmappedFields) {
    throw new _verifierError.default(_verificationSubSteps.SUB_STEPS.computeLocalHash, `${(0, _useCases.getText)('errors', 'foundUnmappedFields')}: ${unmappedFields.join(', ')}`);
  } else {
    return (0, _sha.default)((0, _data.toUTF8Data)(normalizedDocument));
  }
}