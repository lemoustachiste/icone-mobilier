"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getIssuerProfile;

require("core-js/modules/es.promise.js");

var _explorerLookup = require("@blockcerts/explorer-lookup");

var _models = require("../../../models");

var _constants = require("../../../constants");

var _useCases = require("../../i18n/useCases");

var _domain = _interopRequireDefault(require("../../../domain"));

function isValidUrl(url) {
  // https://stackoverflow.com/a/15734347/4064775
  const regex = /^(ftp|http|https):\/\/[^ "]+$/;
  return regex.test(url);
}

function isDidUri(url) {
  return url.startsWith('did:', 0);
}

function isValidV1Profile(profile) {
  // eslint-disable-next-line camelcase,@typescript-eslint/naming-convention
  const {
    issuer_key,
    revocation_key,
    issuerKeys,
    revocationKeys
  } = profile; // eslint-disable-next-line camelcase

  if (!!issuer_key && !!revocation_key) {
    // https://github.com/blockchain-certificates/cert-schema/blob/master/cert_schema/1.1/issuer-schema-v1-1.json
    return true;
  }

  if (issuerKeys && revocationKeys) {
    // https://github.com/blockchain-certificates/cert-schema/blob/master/cert_schema/1.2/issuer-id-1.2.json
    return true;
  }

  return false;
}

function isValidProfile(profile) {
  const validTypes = ['issuer', 'profile']; // https://w3id.org/openbadges#Profile

  const {
    type
  } = profile;

  if (!type) {
    return false;
  }

  if (Array.isArray(type)) {
    return type.some(type => validTypes.includes(type.toLowerCase()));
  }

  return validTypes.includes(type.toLowerCase());
}
/**
 * getIssuerProfile
 *
 * @param issuerAddress: string
 * @returns {Promise<any>}
 */


async function getIssuerProfile(issuerAddress) {
  const errorMessage = (0, _useCases.getText)('errors', 'getIssuerProfile');

  if (!issuerAddress) {
    throw new _models.VerifierError(_constants.SUB_STEPS.getIssuerProfile, `${errorMessage} - ${(0, _useCases.getText)('errors', 'issuerProfileNotSet')}`);
  }

  if (typeof issuerAddress === 'object') {
    issuerAddress = issuerAddress.id;
  }

  let issuerProfile;

  if (isDidUri(issuerAddress)) {
    // TODO: it could be that the issuer profile is embedded, or that it is distant,
    //  but we found a did document so the rest of the function does not apply
    try {
      const didDocument = await _domain.default.did.resolve(issuerAddress);
      const issuerProfileUrl = await _domain.default.did.getIssuerProfileUrl(didDocument);

      if (issuerProfileUrl) {
        issuerProfile = await getIssuerProfile(issuerProfileUrl);
      }

      return {
        // TODO: return more data from the issuer profile
        didDocument,
        ...issuerProfile
      };
    } catch (e) {
      throw new _models.VerifierError(_constants.SUB_STEPS.getIssuerProfile, `${errorMessage} - ${e}`);
    }
  } else if (!isValidUrl(issuerAddress)) {
    throw new _models.VerifierError(_constants.SUB_STEPS.getIssuerProfile, `${errorMessage} - ${(0, _useCases.getText)('errors', 'issuerProfileNotSet')}`);
  }

  issuerProfile = JSON.parse(await (0, _explorerLookup.request)({
    url: issuerAddress
  }).catch(() => {
    throw new _models.VerifierError(_constants.SUB_STEPS.getIssuerProfile, errorMessage);
  }));

  if (!isValidProfile(issuerProfile) && !isValidV1Profile(issuerProfile)) {
    throw new _models.VerifierError(_constants.SUB_STEPS.getIssuerProfile, `${errorMessage} - ${(0, _useCases.getText)('errors', 'issuerProfileInvalid')}`);
  }

  return issuerProfile;
}