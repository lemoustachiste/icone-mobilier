"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = getChain;

var _blockchains = require("../../../constants/blockchains");

var _addresses = _interopRequireDefault(require("../../addresses"));

var _useCases = require("../../i18n/useCases");

var _string = require("../../../helpers/string");

// merkleRoot2019: see https://w3c-dvcg.github.io/lds-merkle-proof-2019/#blockchain-keymap
function getMerkleRoot2019Chain(anchor) {
  const supportedChainsMap = {
    btc: {
      chainName: _blockchains.BLOCKCHAINS.bitcoin.name
    },
    eth: {
      chainName: _blockchains.BLOCKCHAINS.ethmain.name
    }
  };
  const dataArray = anchor.split(':');
  const chainIndex = dataArray.findIndex(data => Object.keys(supportedChainsMap).includes(data));

  if (chainIndex > -1) {
    const chainCode = dataArray[chainIndex];
    const network = dataArray[chainIndex + 1];
    const chainCodeSignatureValue = supportedChainsMap[chainCode].chainName.toLowerCase() + (0, _string.capitalize)(network);
    return getChainObject(chainCodeSignatureValue);
  } else {
    return defaultChainAssumption();
  }
}

function defaultChainAssumption(address = '') {
  return _addresses.default.isMainnet(address) ? _blockchains.BLOCKCHAINS.bitcoin : _blockchains.BLOCKCHAINS.testnet;
}

function getChainObject(chainCodeSignatureValue) {
  const chainObject = Object.keys(_blockchains.BLOCKCHAINS).map(key => _blockchains.BLOCKCHAINS[key]).find(entry => entry.signatureValue === chainCodeSignatureValue);

  if (typeof chainObject === 'undefined') {
    throw new Error((0, _useCases.getText)('errors', 'getChain'));
  }

  return chainObject;
}
/**
 * getChain
 *
 * Returns a chain object by looking at the signature value or the bitcoin address (legacy)
 *
 * @param signature
 * @param address
 * @returns {*}
 */


function getChain(address, proof) {
  const cleanedSignature = proof || null;

  if (cleanedSignature !== null && cleanedSignature !== void 0 && cleanedSignature.anchors) {
    const anchors = cleanedSignature.anchors;
    const anchor = anchors[0];

    if (anchor.chain) {
      const chainCodeSignatureValue = anchor.chain;
      return getChainObject(chainCodeSignatureValue);
    } else if (typeof anchor === 'string') {
      return getMerkleRoot2019Chain(anchor);
    }
  } // Legacy path: we didn't support anything other than testnet and mainnet, so we check the address prefix
  // otherwise try to determine the chain from a bitcoin address


  return defaultChainAssumption(address);
}