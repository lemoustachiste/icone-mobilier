"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVerificationStepsForChain = getVerificationStepsForChain;
exports.default = getVerificationMap;

var _constants = require("../../../constants");

var _chains = _interopRequireDefault(require("../../chains"));

var _useCases = require("../../i18n/useCases");

var _certificateVersions = require("../../../constants/certificateVersions");

var _verificationSubSteps = require("../../../constants/verificationSubSteps");

var _object = require("../../../helpers/object");

var _verificationSteps = require("../../../constants/verificationSteps");

function removeStep(map, step) {
  const checkIssuerIdentityIndex = map.findIndex(subStep => subStep === step);
  map.splice(checkIssuerIdentityIndex, 1);
}

function getVerificationStepsForChain(chain, version, hasDid = false) {
  const network = _chains.default.isMockChain(chain) ? _constants.NETWORKS.testnet : _constants.NETWORKS.mainnet;
  const networkVerificationMap = {
    [_constants.NETWORKS.mainnet]: [_verificationSubSteps.SUB_STEPS.getTransactionId, _verificationSubSteps.SUB_STEPS.computeLocalHash, _verificationSubSteps.SUB_STEPS.fetchRemoteHash, _verificationSubSteps.SUB_STEPS.getIssuerProfile, _verificationSubSteps.SUB_STEPS.parseIssuerKeys, _verificationSubSteps.SUB_STEPS.compareHashes, _verificationSubSteps.SUB_STEPS.checkMerkleRoot, _verificationSubSteps.SUB_STEPS.checkReceipt, _verificationSubSteps.SUB_STEPS.checkIssuerIdentity, _verificationSubSteps.SUB_STEPS.checkRevokedStatus, _verificationSubSteps.SUB_STEPS.checkAuthenticity, _verificationSubSteps.SUB_STEPS.checkExpiresDate],
    [_constants.NETWORKS.testnet]: [_verificationSubSteps.SUB_STEPS.computeLocalHash, _verificationSubSteps.SUB_STEPS.compareHashes, _verificationSubSteps.SUB_STEPS.checkReceipt, _verificationSubSteps.SUB_STEPS.checkIssuerIdentity, _verificationSubSteps.SUB_STEPS.checkExpiresDate]
  };

  if ((0, _certificateVersions.isV3)(version)) {
    removeStep(networkVerificationMap[network], _verificationSubSteps.SUB_STEPS.getIssuerProfile);
  }

  if (!hasDid) {
    removeStep(networkVerificationMap[network], _verificationSubSteps.SUB_STEPS.checkIssuerIdentity);
  }

  return networkVerificationMap[network];
}
/**
 * stepsObjectToArray
 *
 * Turn an object with steps as properties to an array
 *
 * @param stepsObject
 * @returns {{code: string}[]}
 */


function stepsObjectToArray(stepsObject) {
  return Object.keys(stepsObject).map(stepCode => {
    return { ...stepsObject[stepCode],
      code: stepCode,
      label: (0, _useCases.getText)('steps', `${stepCode}Label`),
      labelPending: (0, _useCases.getText)('steps', `${stepCode}LabelPending`)
    };
  });
}
/**
 * setSubStepsToSteps
 *
 * Takes an array of sub-steps and set them to their proper parent step
 *
 * @param subSteps
 * @returns {any}
 */


function setSubStepsToSteps(subSteps) {
  const steps = (0, _object.deepCopy)(_verificationSteps.language);
  subSteps.forEach(subStep => steps[subStep.parentStep].subSteps.push(subStep));
  return steps;
}
/**
 * getFullStepsFromSubSteps
 *
 * Builds a full steps array (with subSteps property) from an array of sub-steps
 *
 * @param subStepMap
 * @returns {Array}
 */


function getFullStepsFromSubSteps(subStepMap) {
  const subSteps = subStepMap.map(stepCode => {
    const subStep = Object.assign({}, _verificationSubSteps.substepsList[stepCode]);
    return { ...subStep,
      label: (0, _useCases.getText)('subSteps', `${stepCode}Label`),
      labelPending: (0, _useCases.getText)('subSteps', `${stepCode}LabelPending`)
    };
  });
  const steps = setSubStepsToSteps(subSteps);
  return stepsObjectToArray(steps);
}
/**
 * getVerificationMap
 *
 * Get verification map from the chain
 *
 * @param chain
 * @returns {Array}
 */


function getVerificationMap(chain, version, hasDid = false) {
  if (!chain) {
    return [];
  }

  return getFullStepsFromSubSteps(getVerificationStepsForChain(chain, version, hasDid));
}