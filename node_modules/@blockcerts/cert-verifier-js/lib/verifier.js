"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

require("core-js/modules/es.promise.js");

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _debug = _interopRequireDefault(require("debug"));

var _verificationStatuses = require("./constants/verificationStatuses");

var _certificateVersions = _interopRequireWildcard(require("./constants/certificateVersions"));

var _domain = _interopRequireDefault(require("./domain"));

var inspectors = _interopRequireWildcard(require("./inspectors"));

var _verificationSteps = require("./constants/verificationSteps");

var _verificationSubSteps = require("./constants/verificationSubSteps");

var _getVerificationMap = require("./domain/certificates/useCases/getVerificationMap");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const log = (0, _debug.default)('Verifier');

class Verifier {
  // TODO: confirm this
  // TODO: define stepStatus interface
  constructor({
    certificateJson,
    chain,
    expires,
    id,
    issuer,
    receipt,
    revocationKey,
    transactionId,
    version,
    explorerAPIs,
    proof
  }) {
    (0, _defineProperty2.default)(this, "chain", void 0);
    (0, _defineProperty2.default)(this, "expires", void 0);
    (0, _defineProperty2.default)(this, "id", void 0);
    (0, _defineProperty2.default)(this, "issuer", void 0);
    (0, _defineProperty2.default)(this, "receipt", void 0);
    (0, _defineProperty2.default)(this, "proof", void 0);
    (0, _defineProperty2.default)(this, "revocationKey", void 0);
    (0, _defineProperty2.default)(this, "version", void 0);
    (0, _defineProperty2.default)(this, "transactionId", void 0);
    (0, _defineProperty2.default)(this, "documentToVerify", void 0);
    (0, _defineProperty2.default)(this, "explorerAPIs", void 0);
    (0, _defineProperty2.default)(this, "txData", void 0);
    (0, _defineProperty2.default)(this, "_stepsStatuses", void 0);
    (0, _defineProperty2.default)(this, "localHash", void 0);
    (0, _defineProperty2.default)(this, "issuerPublicKeyList", void 0);
    this.chain = chain;
    this.expires = expires;
    this.id = id;
    this.issuer = issuer;
    this.receipt = receipt;
    this.revocationKey = revocationKey;
    this.version = version;
    this.transactionId = transactionId;
    this.explorerAPIs = explorerAPIs;
    this.proof = proof;
    let document = certificateJson.document;

    if (!document) {
      document = this._retrieveDocumentBeforeIssuance(certificateJson);
    }

    this.documentToVerify = Object.assign({}, document); // Final verification result
    // Init status as success, we will update the final status at the end

    this._stepsStatuses = [];
  }

  getIssuingAddress() {
    var _this$txData;

    if (!this.txData) {
      console.error('Trying to access issuing address when txData not available yet. Did you run the `verify` method yet?');
    }

    return (_this$txData = this.txData) === null || _this$txData === void 0 ? void 0 : _this$txData.issuingAddress;
  }

  async verify(stepCallback = () => {}) {
    this._stepCallback = stepCallback; // TODO: refactor this with certificate - CALL ONCE VERIFICATION STEPS WITH DID

    const verificationProcess = (0, _getVerificationMap.getVerificationStepsForChain)(this.chain, this.version, !!this.issuer.didDocument);

    for (const verificationStep of verificationProcess) {
      if (!this[verificationStep]) {
        return;
      }

      await this[verificationStep]();
    } // Send final callback update for global verification status


    const erroredStep = this._stepsStatuses.find(step => step.status === _verificationStatuses.VERIFICATION_STATUSES.FAILURE);

    return erroredStep ? this._failed(erroredStep) : this._succeed();
  }

  _getRevocationListUrl(distantIssuerProfile) {
    var _this$issuer;

    // TODO: define revocationList type
    if ((_this$issuer = this.issuer) !== null && _this$issuer !== void 0 && _this$issuer.revocationList) {
      return this.issuer.revocationList;
    }

    return distantIssuerProfile.revocationList;
  }

  async _doAction(step, action) {
    // If not failing already
    if (this._isFailing()) {
      return;
    }

    let label;

    if (step) {
      label = _domain.default.i18n.getText('subSteps', `${step}LabelPending`);
      log(label);

      this._updateStatusCallback(step, label, _verificationStatuses.VERIFICATION_STATUSES.STARTING);
    }

    try {
      const res = await action();

      if (step) {
        this._updateStatusCallback(step, label, _verificationStatuses.VERIFICATION_STATUSES.SUCCESS);

        this._stepsStatuses.push({
          step,
          label,
          status: _verificationStatuses.VERIFICATION_STATUSES.SUCCESS
        });
      }

      return res;
    } catch (err) {
      if (step) {
        this._updateStatusCallback(step, label, _verificationStatuses.VERIFICATION_STATUSES.FAILURE, err.message);

        this._stepsStatuses.push({
          code: step,
          label,
          status: _verificationStatuses.VERIFICATION_STATUSES.FAILURE,
          errorMessage: err.message
        });
      }
    }
  }

  _stepCallback(update) {// TODO: unsure type is indeed any
    // defined by this.verify interface
  }

  async getTransactionId() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.getTransactionId, () => inspectors.isTransactionIdValid(this.transactionId));
  }

  async computeLocalHash() {
    this.localHash = await this._doAction(_verificationSubSteps.SUB_STEPS.computeLocalHash, async () => await inspectors.computeLocalHash(this.documentToVerify, this.version));
  }

  async fetchRemoteHash() {
    this.txData = await this._doAction(_verificationSubSteps.SUB_STEPS.fetchRemoteHash, async () => await _domain.default.verifier.lookForTx({
      transactionId: this.transactionId,
      chain: this.chain.code,
      explorerAPIs: this.explorerAPIs
    }));
  }

  async getIssuerProfile() {
    this.issuer = await this._doAction(_verificationSubSteps.SUB_STEPS.getIssuerProfile, async () => await _domain.default.verifier.getIssuerProfile(this.issuer));
  }

  async parseIssuerKeys() {
    this.issuerPublicKeyList = await this._doAction(_verificationSubSteps.SUB_STEPS.parseIssuerKeys, () => _domain.default.verifier.parseIssuerKeys(this.issuer));
  }

  async compareHashes() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.compareHashes, () => {
      inspectors.ensureHashesEqual(this.localHash, this.receipt.targetHash);
    });
  }

  async checkMerkleRoot() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.checkMerkleRoot, () => inspectors.ensureMerkleRootEqual(this.receipt.merkleRoot, this.txData.remoteHash));
  }

  async checkReceipt() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.checkReceipt, () => inspectors.ensureValidReceipt(this.receipt, this.version));
  }

  async checkRevokedStatus() {
    let keys;
    let revokedAddresses;

    if (this.version === _certificateVersions.default.V1_2) {
      revokedAddresses = this.txData.revokedAddresses;
      keys = [_domain.default.verifier.parseRevocationKey(this.issuer), this.revocationKey];
    } else {
      // Get revoked assertions
      revokedAddresses = await this._doAction(null, async () => await _domain.default.verifier.getRevokedAssertions(this._getRevocationListUrl(this.issuer), this.id));
      keys = this.id;
    }

    await this._doAction(_verificationSubSteps.SUB_STEPS.checkRevokedStatus, () => inspectors.ensureNotRevoked(revokedAddresses, keys));
  }

  async checkAuthenticity() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.checkAuthenticity, () => inspectors.ensureValidIssuingKey(this.issuerPublicKeyList, this.txData.issuingAddress, this.txData.time));
  }

  async checkExpiresDate() {
    await this._doAction(_verificationSubSteps.SUB_STEPS.checkExpiresDate, () => inspectors.ensureNotExpired(this.expires));
  }

  async checkIssuerIdentity() {
    var _this$issuer2;

    if (!((_this$issuer2 = this.issuer) !== null && _this$issuer2 !== void 0 && _this$issuer2.didDocument)) {
      return;
    }

    await this._doAction(_verificationSubSteps.SUB_STEPS.checkIssuerIdentity, () => {
      inspectors.confirmDidSignature({
        didDocument: this.issuer.didDocument,
        proof: this.proof,
        issuingAddress: this.txData.issuingAddress,
        chain: this.chain
      });
    });
  }
  /**
   * Returns a failure final step message
   */


  _failed(errorStep) {
    const message = errorStep.errorMessage;
    log(`failure:${message}`);
    return this._setFinalStep({
      status: _verificationStatuses.VERIFICATION_STATUSES.FAILURE,
      message
    });
  }
  /**
   * whether or not the current verification is failing
   */


  _isFailing() {
    return this._stepsStatuses.some(step => step.status === _verificationStatuses.VERIFICATION_STATUSES.FAILURE);
  }

  _retrieveDocumentBeforeIssuance(certificateJson) {
    // TODO: define certificate object without proof
    const certificateCopy = Object.assign({}, certificateJson);

    if ((0, _certificateVersions.isV3)(this.version)) {
      delete certificateCopy.proof;
    } else {
      delete certificateCopy.signature;
    }

    return certificateCopy;
  }
  /**
   * Returns a final success message
   */


  _succeed() {
    const message = _domain.default.chains.isMockChain(this.chain) ? _domain.default.i18n.getText('success', 'mocknet') : _domain.default.i18n.getText('success', 'blockchain');
    log(message);
    return this._setFinalStep({
      status: _verificationStatuses.VERIFICATION_STATUSES.SUCCESS,
      message
    });
  }

  _setFinalStep({
    status,
    message
  }) {
    return {
      code: _verificationSteps.VerificationSteps.final,
      status,
      message
    };
  }
  /**
   * calls the origin callback to update on a step status
   */


  _updateStatusCallback(code, label, status, errorMessage = '') {
    if (code != null) {
      const update = {
        code,
        label,
        status
      };

      if (errorMessage) {
        update.errorMessage = errorMessage;
      }

      this._stepCallback(update);
    }
  }

}

exports.default = Verifier;