import { TExplorerParsingFunction } from '@blockcerts/explorer-lookup';
import { IDidDocumentPublicKey } from '@decentralized-identity/did-common-typescript';

declare enum Versions {
	V1_1 = "1.1",
	V1_2 = "1.2",
	V2_0 = "2.0",
	V3_0_alpha = "3.0-alpha",
	V3_0_beta = "3.0-beta"
}
export declare type BlockcertsV1 = any;
export declare type BlockcertsV2 = any;
export declare type BlockcertsV3 = any;
export declare type Blockcerts = BlockcertsV1 | BlockcertsV2 | BlockcertsV3;
export interface CustomJsonLDContextDefinition {
	[key: string]: {
		"@id": string;
		"@type": string;
	};
}
export declare type JsonLDContext = Array<string | CustomJsonLDContextDefinition>;
declare enum SupportedChains {
	Bitcoin = "bitcoin",
	Ethmain = "ethmain",
	Ethropst = "ethropst",
	Ethrinkeby = "ethrinkeby",
	Mocknet = "mocknet",
	Regtest = "regtest",
	Testnet = "testnet"
}
export interface IBlockchainObject {
	code: SupportedChains;
	name: string;
	prefixes?: string[];
	test?: boolean;
	signatureValue: string;
	transactionTemplates: {
		full: string;
		raw: string;
	};
}
export declare const BLOCKCHAINS: {
	[chain in SupportedChains]: IBlockchainObject;
};
export interface IDidContext {
	"@base": string;
}
export interface IServiceEndpoint {
	serviceEndpoint?: string;
	type?: string;
	id?: string;
}
export interface IDidDocument {
	id?: string;
	"@context"?: Array<string | IDidContext>;
	verificationMethod?: IDidDocumentPublicKey[];
	authentication?: Array<string | IDidDocumentPublicKey>;
	assertionMethod?: string[];
	service?: IServiceEndpoint[];
	capabilityDelegation?: string[];
	keyAgreement?: IDidDocumentPublicKey[];
	publicKey?: IDidDocumentPublicKey[];
}
export interface KeyObjectV1 {
	date: string;
	key: string;
	invalidated?: string;
}
export interface KeyObjectV2 {
	id: string;
	created: string;
	expires?: string;
	revoked?: string;
}
export interface Issuer {
	"@context"?: string[];
	type?: string;
	id?: string;
	name?: string;
	url?: string;
	image?: string;
	email?: string;
	revocationList?: string;
	publicKey?: string[] | KeyObjectV2[];
	introductionURL?: string;
	introductionAuthenticationMethod?: string;
	introductionSuccessURL?: string;
	introductionErrorURL?: string;
	analyticsURL?: string;
	issuingEstimateAuth?: string;
	issuingEstimateUrl?: string;
	didDocument?: IDidDocument;
	publicKeys?: string[] | KeyObjectV2[];
	issuer_key?: KeyObjectV1[];
	revocation_key?: KeyObjectV1[];
	issuerKeys?: KeyObjectV1[];
	revocationKeys?: KeyObjectV1[];
}
export declare enum SUB_STEPS {
	getTransactionId = "getTransactionId",
	computeLocalHash = "computeLocalHash",
	fetchRemoteHash = "fetchRemoteHash",
	getIssuerProfile = "getIssuerProfile",
	parseIssuerKeys = "parseIssuerKeys",
	compareHashes = "compareHashes",
	checkMerkleRoot = "checkMerkleRoot",
	checkReceipt = "checkReceipt",
	checkIssuerSignature = "checkIssuerSignature",
	checkIssuerIdentity = "checkIssuerIdentity",
	checkAuthenticity = "checkAuthenticity",
	checkRevokedStatus = "checkRevokedStatus",
	checkExpiresDate = "checkExpiresDate"
}
declare enum VerificationSteps {
	formatValidation = "formatValidation",
	hashComparison = "hashComparison",
	statusCheck = "statusCheck",
	final = "final"
}
export interface MerkleProof2019 {
	type: string;
	created: string;
	proofValue: string;
	proofPurpose: string;
	verificationMethod: string;
}
export interface MerklePath {
	left?: string;
	right?: string;
}
export interface MerkleProof2017Anchor {
	sourceId: string;
	type: string;
	chain: string;
}
export interface Receipt {
	path?: MerklePath[];
	merkleRoot?: string;
	targetHash?: string;
	anchors?: string[] | MerkleProof2017Anchor[];
	type?: string[];
	proof?: MerklePath[];
}
export interface IVerificationStepCallbackAPI {
	code: string;
	label: string;
	status: string;
	errorMessage?: string;
}
export declare type IVerificationStepCallbackFn = (update: IVerificationStepCallbackAPI) => any;
export interface IFinalVerificationStatus {
	code: VerificationSteps.final;
	status: string;
	message: string;
}
declare enum TRANSACTION_APIS {
	blockcypher = "blockcypher",
	blockstream = "blockstream",
	etherscan = "etherscan"
}
export declare class SignatureImage {
	image: string;
	jobTitle: string;
	name: string;
	constructor(image: string, jobTitle: string, name: string);
}
export interface ExplorerURLs {
	main: string;
	test: string;
}
export interface ExplorerAPI {
	serviceURL?: string | ExplorerURLs;
	priority?: 0 | 1 | -1;
	parsingFunction?: TExplorerParsingFunction;
	serviceName?: TRANSACTION_APIS;
	key?: string;
	keyPropertyName?: string;
}
export interface CertificateOptions {
	locale?: string;
	explorerAPIs?: ExplorerAPI[];
	didResolverUrl?: string;
}
export declare class Certificate {
	certificateImage?: string;
	certificateJson: Blockcerts;
	chain: IBlockchainObject;
	description?: string;
	expires: string;
	explorerAPIs: ExplorerAPI[];
	id: string;
	isFormatValid: boolean;
	issuedOn: string;
	issuer: Issuer;
	locale: string;
	metadataJson: any;
	name?: string;
	options: CertificateOptions;
	publicKey?: string;
	proof?: MerkleProof2019;
	rawTransactionLink: string;
	receipt: Receipt;
	recipientFullName: string;
	recordLink: string;
	revocationKey: string;
	sealImage?: string;
	signature?: string;
	signatureImage?: SignatureImage[];
	subtitle?: string;
	transactionId: string;
	transactionLink: string;
	verificationSteps: any[];
	version: Versions;
	constructor(certificateDefinition: Blockcerts | string, options?: CertificateOptions);
	init(): Promise<void>;
	verify(stepCallback?: IVerificationStepCallbackFn): Promise<IFinalVerificationStatus>;
	private parseJson;
	private _setOptions;
	private _setProperties;
	private _setTransactionDetails;
}
export declare const VERIFICATION_STATUSES: {
	FAILURE: string;
	STARTING: string;
	SUCCESS: string;
};
export function getSupportedLanguages(): string[];
export declare function retrieveBlockcertsVersion(context: JsonLDContext | string): number;

export {
	Versions as CERTIFICATE_VERSIONS,
};

export {};
