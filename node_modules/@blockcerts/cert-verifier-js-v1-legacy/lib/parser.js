"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parseJSON;

require("core-js/modules/es.promise.js");

var _parsers = require("./parsers");

function lookupVersion(array, v) {
  return array.some(str => str.includes(`v${v}`) || str.includes(`${v}.`));
}

function retrieveBlockcertsVersion(context) {
  if (typeof context === 'string') {
    context = [context];
  }

  const blockcertsContext = context.filter(ctx => typeof ctx === 'string').find(ctx => ctx.toLowerCase().indexOf('blockcerts') > 0);
  const blockcertsContextArray = blockcertsContext.split('/').filter(str => str !== '');
  const availableVersions = Object.keys(_parsers.versionParserMap);
  return parseInt(availableVersions.filter(version => lookupVersion(blockcertsContextArray, version.toString()))[0], 10);
}

async function parseJSON(certificateJson) {
  try {
    const version = retrieveBlockcertsVersion(certificateJson['@context']);

    if (version !== 1) {
      const versionErrorMessage = 'The document you are trying to parse is not Blockcerts V1. Please refer to cert-verifier-js to parse' + ' and verify newer versions: https://github.com/blockchain-certificates/cert-verifier-js';
      console.warn(versionErrorMessage); // eslint-disable-next-line @typescript-eslint/consistent-type-assertions

      return {
        isFormatValid: false,
        error: versionErrorMessage
      };
    }

    const parsedCertificate = await _parsers.versionParserMap[version](certificateJson);
    parsedCertificate.isFormatValid = true;
    return parsedCertificate;
  } catch (error) {
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    return {
      isFormatValid: false,
      error
    };
  }
}