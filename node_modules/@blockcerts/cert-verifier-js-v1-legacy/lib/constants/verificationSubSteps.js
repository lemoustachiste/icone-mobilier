"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.language = exports.checkExpiresDate = exports.checkRevokedStatus = exports.checkAuthenticity = exports.checkIssuerSignature = exports.checkReceipt = exports.checkMerkleRoot = exports.compareHashes = exports.parseIssuerKeys = exports.getIssuerProfile = exports.fetchRemoteHash = exports.computeLocalHash = exports.getTransactionId = void 0;

var STEPS = _interopRequireWildcard(require("./verificationSteps"));

var _i18n = _interopRequireDefault(require("../data/i18n"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const getTransactionId = 'getTransactionId';
exports.getTransactionId = getTransactionId;
const computeLocalHash = 'computeLocalHash';
exports.computeLocalHash = computeLocalHash;
const fetchRemoteHash = 'fetchRemoteHash';
exports.fetchRemoteHash = fetchRemoteHash;
const getIssuerProfile = 'getIssuerProfile';
exports.getIssuerProfile = getIssuerProfile;
const parseIssuerKeys = 'parseIssuerKeys';
exports.parseIssuerKeys = parseIssuerKeys;
const compareHashes = 'compareHashes';
exports.compareHashes = compareHashes;
const checkMerkleRoot = 'checkMerkleRoot';
exports.checkMerkleRoot = checkMerkleRoot;
const checkReceipt = 'checkReceipt';
exports.checkReceipt = checkReceipt;
const checkIssuerSignature = 'checkIssuerSignature';
exports.checkIssuerSignature = checkIssuerSignature;
const checkAuthenticity = 'checkAuthenticity';
exports.checkAuthenticity = checkAuthenticity;
const checkRevokedStatus = 'checkRevokedStatus';
exports.checkRevokedStatus = checkRevokedStatus;
const checkExpiresDate = 'checkExpiresDate';
exports.checkExpiresDate = checkExpiresDate;

function getTextFor(subStep, status) {
  return _i18n.default['en-US'].subSteps[`${subStep}${status}`];
}

const LABEL = 'Label';
const LABEL_PENDING = 'LabelPending';
const subStepsMap = {
  [STEPS.formatValidation]: [getTransactionId, computeLocalHash, fetchRemoteHash, getIssuerProfile, parseIssuerKeys],
  [STEPS.hashComparison]: [compareHashes, checkMerkleRoot, checkReceipt],
  [STEPS.statusCheck]: [checkIssuerSignature, checkAuthenticity, checkRevokedStatus, checkExpiresDate]
};

function generateSubsteps(parentKey) {
  return subStepsMap[parentKey].reduce((acc, curr) => {
    acc[curr] = {
      code: curr,
      label: getTextFor(curr, LABEL),
      labelPending: getTextFor(curr, LABEL_PENDING),
      parentStep: parentKey
    };
    return acc;
  }, {});
}

const language = Object.keys(subStepsMap).reduce((acc, parentStepKey) => {
  return Object.assign(acc, generateSubsteps(parentStepKey));
}, {});
exports.language = language;